1)server component which is by default 
client component

2)-Dynamic Routes-
using square bracket -> [userId]
it give route parameter as params 

product/[proudctId]/review/[reviweId]
{params}:{params:{productId:string;reviewId:string}} -> nested dynamcic routes

-CatchAllSegments-
[...slug]
eg: if i have folder structure docs/[...slug]/page.tsx this will map all the route to page.tsx of slug folder
{params}:{params:{slug:string[]}} -> nested dynamcic routes

docs/[...slug]/page.tsx if you access it like this docs/ only then not found so docs/[[...slug]]/page.tsx



3)not-found.tsx is the page on app folder for custom not found name should be exactly same on nested folder can also be used

so if you have dynamic route
docs/[[...slug]]/page.tsx
you have to add one not-found page 
docs/[[...slug]]/page.tsx not-found
and add code in page.tsx 
import {notFound} from "next/navigation"
if(parseInt(slug) > 1001) {
notFound();}


4)File Colocation
i can make component in same default component

private folders
start with _ and excluded in route
eg: _lib or %5Flib
Private Folders contd.
For separating UI logic from routing logic
For consistently organizing internal files across a projec
For sorting and grouping files in code editors
And finally, for avoiding potential naming conflicts with future Next.js file
conventions
If you want to include an underscore in URL segments, you can prefix the folder
name with "%5F," which is the URL-encoded form of an underscore

route group ()
auth has forget-password,login,signup folder so to access that auth/fodername
and other one is this were auth is  omitted from the route
eg (auth) inside login register forgot password
so we can directly can access /login not /auth/login



5)layout
layout is the component shared between multiple pages in the app
How to Create Layouts
You can define a layout by default exporting a React component from a layout.js
or layout.tsx file
That component should accept a children prop that will be populated with a child
page during rendering

nested layout
export default function ProductDetailsLayout({
children,
}: {
children: React.ReactNode;
}) {
return (

{children}
<h2>Features products</h2>
{/* Carousel here */}
</

Route Group Layout
if i have  (auth)->(with-auth-layout)->login,register;fogetpasswod
this layout will not shared with fogetpassword folder



6)Routing Metadata
Routing Metadata
Ensuring proper search engine optimization (SEO) is crucial for increasing
visibility and attracting users
Next.js introduced the Metadata API which allows you to define metadata for each
page
Metadata ensures accurate and relevant information is displayed when your
pages are shared or indexed

Configuring Metadata
Export a static metadata object
Export a dynamic generateMetadata function
Metadata rules
Both layout.tsx and page.tsx files can export metadata. If defined in a layout, it
applies to all pages in that layout, but if defined in a page, it applies only to that
page
Metadata is read in order, from the root level down to the final page level
When there's metadata in multiple places for the same route, they get combined,
but page metadata will replace layout metadata if they have the same properties

import { Metadata } from "next";

export const metadata: Metadata = {
title:
absolute: "",
default: "Next.js Tutorial - Codevolution",
template: "%s | Codevolution",

description: "Generated by Next.js",

};


7)Routing using Link
Link extend <a> but link dont refesh like a when redirect
import Link from "next/Link"

<Link href="/blog">Blog</Link>


<Link href="/blog" replace>Blog</Link> remove history

when we want url of the in browser search
import {usePathname} from "next/navigation";

const pathname = usePathname();
return (
<div>
{navLinks.map((link) => {
const isActive = pathname.startsWith(link.href);
return (
<Link href={link.href} key={link.name}
className=HisActive ? "font-bold mr-4" : "text-blue-500 mr-4 >

{link.name}
</Link>
>
);
{children}


Navigating Programmatically
import { useRouter } from "next/navigation";
  const router = useRouter();
 function handleClick() {
    router.push("/");
  }


template.tsx(refresh page) vs layout.tsx
Templates
Templates are similar to layouts in that they wrap each child layout or page
But, with templates, when a user navigates between routes that share a template,
a new instance of the component is mounted, DOM elements are recreated, state
is not preserved, and effects are re-synchronized
A template can be defined by exporting a default React component from a
template.js or template.tsx file
Similar to layouts, templates also should accept a children prop which will render
the nested segments in the route.


loading.tsx
This file allows us to create loading states that are displayed to users while a
specific route segment's content is loading
The loading state appears immediately upon navigation, giving users the
assurance that the application is responsive and actively loading content
loading.tsx wrap page.tsx 

Error
error.tsx bubble up and on nested child
in page
  if (random === 1) {
    throw new Error("loading review");
  }

in error
"use client"
import React from "react";

export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div>
      {error.message} <button onClick={reset}></button>
    </div>
  );
}

****if layout and error on same folder adjacent when error in layout it will not show to handle this put the error on the parent folder
<Layout>
<Template>
<ErrorBoundary fallback={<Error />}>
<Suspense fallback={<Loading />}>
<ErrorBoundary fallback={<NotFound />}>
<Page />
</ErrorBoundary>
</Suspense>
</ErrorBoundary>
</Template>
</Layout>


Parallel Routes
Parallel routes are an advanced routing mechanism that allows for the
simultaneous rendering of multiple pages within the same layout
using slot @foldername
this slot are passed to its corresponding layout.tsx file
independent routes ,error ,loading,sub navigation,
navigaton with route
Parallel Routes contd.
Parallel routes in Next.js are defined using a feature known as slots
Slots help structure our content in a modular fashion
To define a slot, we use the `@folder' naming convention
Each slot is then passed as a prop to its corresponding 'layout.tsx' file.
A clear benefit of parallel routes is their ability to split a single layout into various
slots, making the code more manageable
Independent route handling
Each slot of your layout, such as user analytics or revenue metrics, can have its
own loading and error states
This granular control is particularly beneficial in scenarios where different sections
of the page load at varying speeds or encounter unique errors
Sub-navigation in routes
Each slot of your dashboard can essentially function as a mini-application,
complete with its own navigation and state management
This is especially useful in a complex application such as our dashboard where
different sections serve distinct purposes.
export default function DashboardLayout (
children,
users,
revenue,
notifications,
children: React.ReactNode;
users: React. ReactNode;
revenue: React.ReactNode;
notifications: React.ReactNode;
return (
<div>
<div>{children}</div>
<div style={{ display: "flex" }}>
<div style={{ display: "flex", flexDirection: "column" }}>
<div>{users}</div>
<div>{revenue}</div>
</div>
<div style={{ display: "flex", flex: 1 }}>{notifications}</div>
</div>
</div>


-Handle Unmatched Routes-
In the case of navigation within the UI, Next.js retains the previously active state of
a slot regardless of changes in the URL.
Page reload
Next.js immediately searches for a default.tsx file within each unmatched slot
The presence of this file is critical, as it provides the default content that Next.js
will render in the user interface

If this default.tsx file is missing in any of the unmatched slots for the current route,
Next.js will render a 404 error.

The default.tsx file is nextjs serves as a fallback to render content when the same framework cannot retrieve the slot acting state from the current URL

Navigation from the UI in the case of Navigator within a UI next.js details the previous active state of a slot regardless of change in URL

page reader :
Next JS immediately search for the default.tsx file within each unmatched slot 
The presence of this file is critical as it provides the default content that next JS will render in the user interface
 if the default.tsx file is missing in any of the unmatched slots for the current route next js will render 404 error


Intercepting Routes 
Intercepting routes allow you to intercept or stop the default routing behaviour to
present an alternate view or component when navigating through the UI, while still
preserving the intended route for scenarios like page reloads

eg- model of photo pop up and signup page we can go back and using the back in browser and open a new page of login if made 

Intercepting Routes Conventions

(.) to match segments on the same level

( .. ) to match segments one level above

( .. )( .. ) to match segments two levels above

( ... ) to match segments from the root app directory
folder same place 
(.)f2
f2

Route Handlers
We've learnt how to route to pages
We can also create custom request handlers for our routes using a feature called
route handlers
Unlike page routes, which respond with HTML content, route handlers allow you to
create RESTful endpoints, giving you full control over the response
There is no overhead of having to create and configure a separate server
Route handlers are also great for making external API requests
Route handlers run server-side, ensuring that sensitive information like private
keys remains secure and never gets shipped to the browser
Route Handlers are the equivalent of API routes in Page router

route.ts
make folder api and put it in
export async function GET() {
  return Response.json(comments);
}
export async function GET() {
    
  return new Response("GET  handler");
}

it has request and context as paramaeter GET PATCH DELETE


import { comments } from "./data";

export async function GET() {
return Response.json(comments);

}

export async function POST(request: Request)
const comment = await request.json();
const newcomment = {
id: comments. length + 1,
text: comment.text,

comments.push (newcomment) ;I
return new Response(JSON.stringify(newcomment), {
headers: {
"Content-Type": "application/json",

status: 201,
});


Dynamic Route Handlers
const GET = async (
  request: Request,
  { params }: { params: { id: string } }
) => {
  return new Response(`ID:${params.id}`);
};

export default GET;


const GET = async (
  request: Request,
  { params }: { params: { id: string } }
) => {
const body = await request.json();
  return new Response(`ID:${params.id}`);
};

export default GET;


URL Query Parameters
import { NextRequest } from "next/server";

const GET = async (request: NextRequest) => {
  const searchParams = request.nextUrl.searchParams;
  //http://localhost:3000?query:12
  const query = searchParams.get("query");
};

export default GET;

Redirects in Route Handlers
redirect("/comment")


Headers in Route Handlers
import { headers } from "next/headers";
import { NextRequest } from "next/server";

const GET = async (request: NextRequest) => {
  //first
  const requestHeaders = new Headers(request.headers);
  //second
  const headerList = headers();
  console.log(requestHeaders.get("Authorization"));
  console.log(headerList.get("Authorization"));
};

export default GET;

returning header

const GET = async (request: NextRequest) => {
  //first
  const requestHeaders = new Headers(request.headers);
  //second
  const headerList = headers();
  console.log(requestHeaders.get("Authorization"));
  console.log(headerList.get("Authorization"));

  return new Response("<h1> Profile API data</h1>", {
    headers: {
      "Content-Type": "text/html",
    },
  });
};

//cookies
import { cookies, headers } from "next/headers";
import { NextRequest } from "next/server";

const GET = async (request: NextRequest) => {
  const headerList = headers();
  console.log(headerList.get("Authorization"));

  //first
  cookies().set("resultPerPage", "20");
  const theme = request.cookies.get("theme");

  return new Response("<h1> Profile API data</h1>", {
    headers: {
      "Content-Type": "text/html",
      "Set-Cookie": "theme=dark",
    },
  });
};

export default GET;

Caching in Route Handlers

Route Handlers are cached by default when using the GET method with the
Response object in Next.js

How to opt out of caching?

- dynamic mode in Segment Config Option
- using the Request object with the GET method
- employing dynamic functions like headers() and cookies()
- using any HTTP method other than GET


Middleware
Middleware in Next.js is a powerful feature that offers a robust way to intercept
and control the flow of requests and responses within your applications
It does this at a global level significantly enhancing features like redirection, URL
rewrites, authentication, headers and cookies management, and more.

middleware.ts
import { NextResponse, type NextRequest } from "next/server";

export function middleware(request: NextRequest) {
const response = NextResponse.next();

const themePreference = request.cookies.get("theme");
if (!themePreference) {
response. cookies.set("theme", "dark");

response. headers. set("custom-header", "custom-value;

return response;
if (request.nextUrl.pathname === "/profile") {
return NextResponse. rewrite(new URL("/hello", request.url))

return NextResponse. redirect(new URL("/", request.url));

// export const config = {
matcher: "/profile",

Client-side Rendering
This method of rendering, where the component code is transformed into a user
interface directly within the browser (the client), is known as client-side rendering
(CSR)
CSR quickly became the standard for SPAs, with widespread adoption
It wasn't long before developers began noticing some inherent drawbacks to this
approach
Drawbacks of CSR

SEO

Generating HTML that mainly contains a single div tag is not optimal for SEO, as it
provides little content for search engines to index

Performance

Having the browser (the client) handle all the work, such as fetching data,
computing the UI, and making the HTML interactive, can slow things down. Users
might see a blank screen or a loading spinner while the page loads

Each new feature added to the application increases the size of the JavaScript
bundle, prolonging the wait time for users to see the UI

Recollecting Drawbacks of CSR

Reliance on JavaScript for rendering content on the client side can significantly
hurt SEO, as search engines might struggle to index the content properly

The user experience can suffer from slow load times, as the browser has to
download, parse, and execute JavaScript before the user sees any meaningful
content on the page



nextjs 15

import React from "react";

const UserProfile = async ({ params }: { params: { id: string } }) => {
  const { id } = await params;
  return <div>Product : {id}</div>;
};

export default UserProfile;


import { usePathname } from "next/navigation";
import React from "react";

const Navigation: React.FC = () => {
  const pathname = usePathname();
  return (
    <nav>
      <Link
        href="/"
        className={pathname === "/" ? "font-bold mr-4" : "text-blue-400 mr-4"}
      >
        Home
      </Link>
      <Link
        href="/about"
        className={
          pathname === "/about" ? "font-bold mr-4" : "text-blue-400 mr-4"
        }
      >


