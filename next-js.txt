1)server component which is by default 
client component

2)-Dynamic Routes-
using square bracket -> [userId]
it give route parameter as params 

product/[proudctId]/review/[reviweId]
{params}:{params:{productId:string;reviewId:string}} -> nested dynamcic routes

-CatchAllSegments-
[...slug]
eg: if i have folder structure docs/[...slug]/page.tsx this will map all the route to page.tsx of slug folder
{params}:{params:{slug:string[]}} -> nested dynamcic routes

docs/[...slug]/page.tsx if you access it like this docs/ only then not found so docs/[[...slug]]/page.tsx



3)not-found.tsx is the page on app folder for custom not found name should be exactly same on nested folder can also be used

so if you have dynamic route
docs/[[...slug]]/page.tsx
you have to add one not-found page 
docs/[[...slug]]/page.tsx not-found
and add code in page.tsx 
import {notFound} from "next/navigation"
if(parseInt(slug) > 1001) {
notFound();}


4)File Colocation
i can make component in same default component

private folders
start with _ and excluded in route
eg: _lib or %5Flib
Private Folders contd.
For separating UI logic from routing logic
For consistently organizing internal files across a projec
For sorting and grouping files in code editors
And finally, for avoiding potential naming conflicts with future Next.js file
conventions
If you want to include an underscore in URL segments, you can prefix the folder
name with "%5F," which is the URL-encoded form of an underscore

route group ()
auth has forget-password,login,signup folder so to access that auth/fodername
and other one is this were auth is  omitted from the route
eg (auth) inside login register forgot password
so we can directly can access /login not /auth/login



5)layout
layout is the component shared between multiple pages in the app
How to Create Layouts
You can define a layout by default exporting a React component from a layout.js
or layout.tsx file
That component should accept a children prop that will be populated with a child
page during rendering

nested layout
export default function ProductDetailsLayout({
children,
}: {
children: React.ReactNode;
}) {
return (

{children}
<h2>Features products</h2>
{/* Carousel here */}
</

Route Group Layout
if i have  (auth)->(with-auth-layout)->login,register;fogetpasswod
this layout will not shared with fogetpassword folder

6)Routing Metadata
Routing Metadata
Ensuring proper search engine optimization (SEO) is crucial for increasing
visibility and attracting users
Next.js introduced the Metadata API which allows you to define metadata for each
page
Metadata ensures accurate and relevant information is displayed when your
pages are shared or indexed

Configuring Metadata
Export a static metadata object
Export a dynamic generateMetadata function
Metadata rules
Both layout.tsx and page.tsx files can export metadata. If defined in a layout, it
applies to all pages in that layout, but if defined in a page, it applies only to that
page
Metadata is read in order, from the root level down to the final page level
When there's metadata in multiple places for the same route, they get combined,
but page metadata will replace layout metadata if they have the same properties

import { Metadata } from "next";

export const metadata: Metadata = {
title:
absolute: "",
default: "Next.js Tutorial - Codevolution",
template: "%s | Codevolution",

description: "Generated by Next.js",

};


7)Routing using Link
Link extend <a> but link dont refesh like a when redirect
import Link from "next/Link"

<Link href="/blog">Blog</Link>


<Link href="/blog" replace>Blog</Link> remove history

when we want url of the in browser search
import {usePathname} from "next/navigation";

const pathname = usePathname();
return (
<div>
{navLinks.map((link) => {
const isActive = pathname.startsWith(link.href);
return (
<Link href={link.href} key={link.name}
className=HisActive ? "font-bold mr-4" : "text-blue-500 mr-4 >

{link.name}
</Link>
>
);
{children}


Navigating Programmatically
import { useRouter } from "next/navigation";
  const router = useRouter();
 function handleClick() {
    router.push("/");
  }


template.tsx(refresh page) vs layout.tsx
Templates
Templates are similar to layouts in that they wrap each child layout or page
But, with templates, when a user navigates between routes that share a template,
a new instance of the component is mounted, DOM elements are recreated, state
is not preserved, and effects are re-synchronized
A template can be defined by exporting a default React component from a
template.js or template.tsx file
Similar to layouts, templates also should accept a children prop which will render
the nested segments in the route.


loading.tsx
This file allows us to create loading states that are displayed to users while a
specific route segment's content is loading
The loading state appears immediately upon navigation, giving users the
assurance that the application is responsive and actively loading content
loading.tsx wrap page.tsx 

Error
error.tsx bubble up and on nested child
in page
  if (random === 1) {
    throw new Error("loading review");
  }

in error
"use client"
import React from "react";

export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div>
      {error.message} <button onClick={reset}></button>
    </div>
  );
}

**if layout and error on same folder adjacent when error in layout it will not show to handle this put the error on the parent folder
<Layout>
<Template>
<ErrorBoundary fallback={<Error />}>
<Suspense fallback={<Loading />}>
<ErrorBoundary fallback={<NotFound />}>
<Page />
</ErrorBoundary>
</Suspense>
</ErrorBoundary>
</Template>
</Layout>


Parallel Routes
Parallel routes are an advanced routing mechanism that allows for the
simultaneous rendering of multiple pages within the same layout
using slot @foldername
this slot are passed to its corresponding layout.tsx file
independent routes ,error ,loading,sub navigation,
navigaton with route
Parallel Routes contd.
Parallel routes in Next.js are defined using a feature known as slots
Slots help structure our content in a modular fashion
To define a slot, we use the `@folder' naming convention
Each slot is then passed as a prop to its corresponding 'layout.tsx' file.
A clear benefit of parallel routes is their ability to split a single layout into various
slots, making the code more manageable
Independent route handling
Each slot of your layout, such as user analytics or revenue metrics, can have its
own loading and error states
This granular control is particularly beneficial in scenarios where different sections
of the page load at varying speeds or encounter unique errors
Sub-navigation in routes
Each slot of your dashboard can essentially function as a mini-application,
complete with its own navigation and state management
This is especially useful in a complex application such as our dashboard where
different sections serve distinct purposes.
export default function DashboardLayout (
children,
users,
revenue,
notifications,
children: React.ReactNode;
users: React. ReactNode;
revenue: React.ReactNode;
notifications: React.ReactNode;
return (
<div>
<div>{children}</div>
<div style={{ display: "flex" }}>
<div style={{ display: "flex", flexDirection: "column" }}>
<div>{users}</div>
<div>{revenue}</div>
</div>
<div style={{ display: "flex", flex: 1 }}>{notifications}</div>
</div>
</div>


-Handle Unmatched Routes-
In the case of navigation within the UI, Next.js retains the previously active state of
a slot regardless of changes in the URL.
Page reload
Next.js immediately searches for a default.tsx file within each unmatched slot
The presence of this file is critical, as it provides the default content that Next.js
will render in the user interface

If this default.tsx file is missing in any of the unmatched slots for the current route,
Next.js will render a 404 error.

The default.tsx file is nextjs serves as a fallback to render content when the same framework cannot retrieve the slot acting state from the current URL

Navigation from the UI in the case of Navigator within a UI next.js details the previous active state of a slot regardless of change in URL

page reader :
Next JS immediately search for the default.tsx file within each unmatched slot 
The presence of this file is critical as it provides the default content that next JS will render in the user interface
 if the default.tsx file is missing in any of the unmatched slots for the current route next js will render 404 error


Intercepting Routes 
Intercepting routes allow you to intercept or stop the default routing behaviour to
present an alternate view or component when navigating through the UI, while still
preserving the intended route for scenarios like page reloads

eg- model of photo pop up and signup page we can go back and using the back in browser and open a new page of login if made 

Intercepting Routes Conventions

(.) to match segments on the same level

( .. ) to match segments one level above

( .. )( .. ) to match segments two levels above

( ... ) to match segments from the root app directory
folder same place 
(.)f2
f2

Route Handlers
We've learnt how to route to pages
We can also create custom request handlers for our routes using a feature called
route handlers
Unlike page routes, which respond with HTML content, route handlers allow you to
create RESTful endpoints, giving you full control over the response
There is no overhead of having to create and configure a separate server
Route handlers are also great for making external API requests
Route handlers run server-side, ensuring that sensitive information like private
keys remains secure and never gets shipped to the browser
Route Handlers are the equivalent of API routes in Page router

route.ts
make folder api and put it in
export async function GET() {
  return Response.json(comments);
}
export async function GET() {
    
  return new Response("GET  handler");
}

it has request and context as paramaeter GET PATCH DELETE


import { comments } from "./data";

export async function GET() {
return Response.json(comments);

}

export async function POST(request: Request)
const comment = await request.json();
const newcomment = {
id: comments. length + 1,
text: comment.text,

comments.push (newcomment) ;I
return new Response(JSON.stringify(newcomment), {
headers: {
"Content-Type": "application/json",

status: 201,
});


Dynamic Route Handlers
const GET = async (
  request: Request,
  { params }: { params: { id: string } }
) => {
  return new Response(`ID:${params.id}`);
};

export default GET;


const GET = async (
  request: Request,
  { params }: { params: { id: string } }
) => {
const body = await request.json();
  return new Response(`ID:${params.id}`);
};

export default GET;


URL Query Parameters
import { NextRequest } from "next/server";

const GET = async (request: NextRequest) => {
  const searchParams = request.nextUrl.searchParams;
  //http://localhost:3000?query:12
  const query = searchParams.get("query");
};

export default GET;

Redirects in Route Handlers
redirect("/comment")


Headers in Route Handlers
import { headers } from "next/headers";
import { NextRequest } from "next/server";

const GET = async (request: NextRequest) => {
  //first
  const requestHeaders = new Headers(request.headers);
  //second
  const headerList = headers();
  console.log(requestHeaders.get("Authorization"));
  console.log(headerList.get("Authorization"));
};

export default GET;

returning header

const GET = async (request: NextRequest) => {
  //first
  const requestHeaders = new Headers(request.headers);
  //second
  const headerList = headers();
  console.log(requestHeaders.get("Authorization"));
  console.log(headerList.get("Authorization"));

  return new Response("<h1> Profile API data</h1>", {
    headers: {
      "Content-Type": "text/html",
    },
  });
};

//cookies
import { cookies, headers } from "next/headers";
import { NextRequest } from "next/server";

const GET = async (request: NextRequest) => {
  const headerList = headers();
  console.log(headerList.get("Authorization"));

  //first
  cookies().set("resultPerPage", "20");
  const theme = request.cookies.get("theme");

  return new Response("<h1> Profile API data</h1>", {
    headers: {
      "Content-Type": "text/html",
      "Set-Cookie": "theme=dark",
    },
  });
};

export default GET;

Caching in Route Handlers

Route Handlers are cached by default when using the GET method with the
Response object in Next.js

How to opt out of caching?

- dynamic mode in Segment Config Option
- using the Request object with the GET method
- employing dynamic functions like headers() and cookies()
- using any HTTP method other than GET


Middleware
Middleware in Next.js is a powerful feature that offers a robust way to intercept
and control the flow of requests and responses within your applications
It does this at a global level significantly enhancing features like redirection, URL
rewrites, authentication, headers and cookies management, and more.

middleware.ts
import { NextResponse, type NextRequest } from "next/server";

export function middleware(request: NextRequest) {
const response = NextResponse.next();

const themePreference = request.cookies.get("theme");
if (!themePreference) {
response. cookies.set("theme", "dark");

response. headers. set("custom-header", "custom-value;

return response;
if (request.nextUrl.pathname === "/profile") {
return NextResponse. rewrite(new URL("/hello", request.url))

return NextResponse. redirect(new URL("/", request.url));

// export const config = {
matcher: "/profile",

SSR
hydration
During hydration, React takes control in the browser, reconstructing the
component tree in memory based on the static HTML that was served

It carefully plans the placement of interactive elements within this tree. Then,
React proceeds to bind the necessary JavaScript logic to these elements

This involves initializing the application state, attaching event handlers for actions
such as clicks and mouseovers, and setting up any other dynamic functionalities
required for a fully interactive user experience

Drawbacks of SSR - All or Nothing Waterfall

1.Data fetching must be completed before the server can begin rendering
HTML

2. The JavaScript required for the components needs to be fully loaded on the
client side before the hydration process can start
3. All components have to be hydrated before they become interactive

These issues contribute to an 'all-or-nothing' waterfall scenario, resulting in
inefficiencies, especially if certain parts of your application are slower than others

solution
Selective Hydration on the Client

By wrapping the main section within `<Suspense>`, you've indicated to React that
it should not prevent the rest of the page from not just streaming but also from
hydrating

This feature, called selective hydration allows for the hydration of sections as
they become available, before the rest of the HTML and the JavaScript code are
fully downloaded

Thanks to Selective Hydration, a heavy piece of JS doesn't prevent the rest of the
page from becoming interactive

Selective Hydration offers a solution to the third issue: the necessity to "hydrate
everything to interact with anything"

React begins hydrating as soon as possible, enabling interactions with elements
like the header and side navigation without waiting for the main content to be
hydrated

This process is managed automatically by React

In scenarios where multiple components are awaiting hydration, React prioritizes
hydration based on user interactions

Drawbacks of Suspense SSR

First, even though JavaScript code is streamed to the browser asynchronously,
eventually, the entire code for a web page must be downloaded by the user

As applications add more features, the amount of code users need to download
also grows. This leads to an important question:

should users really have to download so much data?
Second, the current approach requires that all React components undergo
hydration on the client-side, irrespective of their actual need for interactivity

This process can inefficiently spend resources and extend the loading times and
time to interactivity for users, as their devices need to process and render
components that might not even require client-side interaction
Third, in spite of servers' superior capacity for handling intensive processing tasks,
the bulk of JavaScript execution still takes place on the user's device

This can slow down the performance, especially on devices that are not very
powerful

This leads to another important question:

should so much of the work be done on the user's device?

solution
rsc

SSG
SSG occurs at build time, when the application is deployed on the server. This
results in pages that are already rendered and ready to serve. It is ideal for
content that doesn't change often, like blog posts

Client-side Rendering
This method of rendering, where the component code is transformed into a user
interface directly within the browser (the client), is known as client-side rendering
(CSR)
CSR quickly became the standard for SPAs, with widespread adoption
It wasn't long before developers began noticing some inherent drawbacks to this
approach
Drawbacks of CSR


SEO

Generating HTML that mainly contains a single div tag is not optimal for SEO, as it
provides little content for search engines to index

Performance

Having the browser (the client) handle all the work, such as fetching data,
computing the UI, and making the HTML interactive, can slow things down. Users
might see a blank screen or a loading spinner while the page loads

Each new feature added to the application increases the size of the JavaScript
bundle, prolonging the wait time for users to see the UI

Recollecting Drawbacks of CSR

Reliance on JavaScript for rendering content on the client side can significantly
hurt SEO, as search engines might struggle to index the content properly

The user experience can suffer from slow load times, as the browser has to
download, parse, and execute JavaScript before the user sees any meaningful
content on the page


React Server Components (RSC)
React Server Components (RSC) represent a new architecture designed by the
React team

This approach aims to leverage the strengths of both server and client
environments, optimizing for efficiency, load times, and interactivity

The architecture introduces a dual-component model

- Client Components
- Server Components

This distinction is not based on the functionality of the components but rather on
where they execute and the specific environments they are designed to interact
with

Server Components
Server Components represent a new type of React component specifically
designed to operate exclusively on the server

And unlike client components, their code stays on the server and is never
downloaded to the client

This design choice offers multiple benefits to React applications

In the RSC architecture and by extension in the Next.js app router, components
are server components by default

To use client components, you must include the use client directive at the top

Server components are rendered only on the server

Client components are rendered once on the server and then on the client

Rending technique(static, dynamic, streaming) html from server to client

static default cache
Static rendering is a strategy where the HTML is generated at build time

Along with the HTML, the RSC payload is created for each component, and
JavaScript chunks are produced for client-side component hydration in the
browser

If you navigate directly to a page route, the corresponding HTML file is served

I you navigate to the route from a different one, the route is created on the client
side using the RSC payload and JavaScript chunks, without any additional
requests to the server


dynamic
Dynamic rendering is a strategy where the HTML is generated at request time

Next.js automatically switches to dynamic rendering when it comes across a
dynamic function in the component, such as cookies(), headers(), or the
searchParams object

This form of rendering is great for when we need to render HTML personalized to
a user, such as a social media feed

As a developer, you do not need to choose between static and dynamic rendering.
Next.js will automatically choose the best rendering strategy for each route based
on the features and APIs used
nextjs 15

Sreaming
import { Suspense } from "react";

import { Product } from "@/components/product";
import { Reviews } from "@/components/reviews";

export default function ProductDetailPage() {
return
<div>
<h1>Product detail page</h1>
<Suspense fallback={<p>Loading product details ...< /p>}>
<Product />
</Suspense>
<Suspense fallback={<p>Loading reviews ...< /p>}>
<Reviews />
</Suspense>
</div>

}

RSC payload 

Server only
npm i server-only

Clent only
npm i client-only

Request Memoization defaut feature
Request memoization is a React feature, not specifically a Next.js feature

Memoization only applies to the GET method in fetch requests

Memoization only applies within the React Component tree. It does not extend to
fetch requests in Route Handlers as they are not part of the React component tree

For cases where fetch is not suitable (e.g., some database clients, CMS clients, or
GraphQL clients), you can use the React cache function to memoize functions

Revalidation
You can set the revalidate route segment configuration to establish the default
revalidation time for a layout or page: export const revalidate = 10;

Regarding the revalidation frequency, the lowest revalidate time across each
layout and page of a single route will determine the revalidation frequency of the
entire route
revalidate
const response = await fetch("http://localhost:3001/products", {
next: {
revalidate: 10,}})

client side data fetching
can use tanstack query 

Caching
fullroute cache -> time-based on-demand disable 
data caching
router caching 
request momoiztion

rendering mode -> ssg isr ssr 
Static Routes (SSG)	Fully cached (Build Time)	Use ISR (revalidate: X)
Dynamic Routes (ISR Incremental Static Regeneration)	Cached, updates after X sec	Change revalidate value
SSR (Server-Side Rendering)	No caching (fetches on request)	Always fresh, can't cache
Client-Side Fetching	No caching by default	Use SWR, React Query
Server Components	Cached (auto)	Use cache: "no-store" or revalidate

 (Solid Circle)	Static Page (SSG)	Pre-rendered at build time and cached. Great for SEO.
○ (Hollow Circle)	Static Page (ISR)	Pre-rendered but can be updated using ISR (revalidate).
λ (Lambda)	Server-Side Rendering (SSR)	Page is rendered on request at runtime (not cached).
⚡ (Lightning Bolt)	Edge Function	Page/API runs on the Edge (faster, globally distributed).
⊙ (Dynamic without pre-render)	Fallback Page	Used when ISR is enabled and the page is being generated.

fully cache 
on demand choice based aching /delete & create revalidatePath("/");
disable caching i wand everytime fresh data export const dynamic = "force-dynamic"; export const revalidate=0;



Server Action
Server Actions is a new experimental feature in Next.js 14+ that allows you to run server-side logic directly from a React component without using API routes.

"use client"; // Required for event handlers

async function submitContactForm(formData) {
  "use server"; // Marks this function as a Server Action

  // Simulate saving to a database (Replace with real DB logic)
  console.log("Form Submitted:", formData.get("name"), formData.get("message"));

  return { success: true };
}

export default function ContactForm() {
  async function handleSubmit(formData) {
    const response = await submitContactForm(formData);
    if (response.success) alert("Form submitted successfully!");
  }

  return (
    <form action={handleSubmit}>
      <input name="name" placeholder="Your Name" required />
      <textarea name="message" placeholder="Your Message" required />
      <button type="submit">Send</button>
    </form>
  );
}

or

"use server";
import { db } from "@/lib/db"; // Your database connection

export async function addUser(formData) {
  const name = formData.get("name");
  const email = formData.get("email");

  await db.user.create({
    data: { name, email },
  });

  return { success: true };
}

<form action={addUser}>
  <input name="name" placeholder="Name" required />
  <input name="email" placeholder="Email" required />
  <button type="submit">Add User</button>
</form>



note
we can put client component inside the server component
when a server component is used inside the client component it change to client component and it children also so use client component less and in place were need solution we can pass as children  prop
data is cached on server so if there console.log it will only log one time and all static routes are cached server side persisten cache and its called Data cache not browser cache
For individual data fetches, you can opt out of caching by setting the cache option
to no-store

Once you specify the no-store option for a fetch request, subsequent fetch
requests will also not be cached

By default, Next.js will cache fetch() requests that occur before any dynamic
functions (cookies(), headers(), searchParams) are used and will not cache
requests found after dynamic functions

browser-> server(rendering -> request memoization->data cache->datasource)

We also know that we can opt out of caching

- by using the cache: "no-store" option in a fetch request
- by using a dynamic function before making the fetch request
- by using a route segment config like fetch-cache or dynamic


next js 15
no cache in fetch request are no longer cached by defualt

Therefore, we are transitioning APIs that rely on request-specific
data-such as headers, cookies, params, and searchParams -to
be asynchronous.
export default async function Page({ params }: { params:
Promise<{ id: string }> }) {
const id = (await params).id
}


turbo pack 
add "dev": "next dev --turbo"
get  route handler are no longer cached by default





import React from "react";

const UserProfile = async ({ params }: { params: { id: string } }) => {
  const { id } = await params;
  return <div>Product : {id}</div>;
};


export default UserProfile;


import { usePathname } from "next/navigation";
import React from "react";

const Navigation: React.FC = () => {
  const pathname = usePathname();
  return (
    <nav>
      <Link
        href="/"
        className={pathname === "/" ? "font-bold mr-4" : "text-blue-400 mr-4"}
      >
        Home
      </Link>
      <Link
        href="/about"
        className={
          pathname === "/about" ? "font-bold mr-4" : "text-blue-400 mr-4"
        }
      >


